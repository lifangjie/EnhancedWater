// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "UnityCG.cginc"
#include "Random.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

uniform int Size;
uniform float Length;
uniform float PhillipsSpectrum;
uniform float2 Wind;
uniform float Gravity;

float Phillips(float2 k) {
    float kLength = length(k);

    float kLength2 = kLength * kLength;
    float kLength4 = kLength2 * kLength2;

    float kDotW = dot(normalize(k), normalize(Wind));
    float kDotW2 = kDotW * kDotW;

    float wLength = length(Wind);
    float l = wLength * wLength / Gravity;
    float l2 = l * l;

    float damping = 0.001;
    float l2Damping2 = l2 * damping * damping;

    return PhillipsSpectrum * exp(-1.0 / (kLength2 * l2)) / kLength4 * kDotW2 * exp(-kLength2 * l2Damping2);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float x1, x2, w, randNum;
	SetSeed(id.x * 512 + id.y);
    x1 = 2 * Rand() - 1;
    x2 = 2 * Rand() - 1;
    w = x1 * x1 + x2 * x2;
    w = sqrt(-2 * log(w) / w);
    float2 gaussianRandomVar = float2(x1 * w, x2 * w);
    float2 k = float2(UNITY_PI * (2 * float(id.x) - Size) / Length, UNITY_PI * (2 * float(id.y) - Size) / Length);
    Result[id.xy] = float4(gaussianRandomVar * sqrt(Phillips(k) / 2.0), gaussianRandomVar * sqrt(Phillips(-k) / 2.0));
}


